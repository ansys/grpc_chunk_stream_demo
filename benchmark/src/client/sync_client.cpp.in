#include <cstdio>
#include <cstdint>
#include <vector>
#include <chrono>
#include <functional>

#include <grpcpp/grpcpp.h>

#include <types_lookup.hpp>
#include "send_array.grpc.pb.h"
#include "clientlib.hpp"

using namespace send_array;


template<typename GrpcType>
int64_t measure_runtime(
    ArrayServiceClient<GrpcType>& client,
    std::function<void(std::vector<typename TypesLookup<GrpcType>::data_type> &)> array_getter,
    std::size_t vec_size,
    std::size_t num_repetitions,
    std::size_t num_preheat,
    std::function<void(std::vector<typename TypesLookup<GrpcType>::data_type> &, std::size_t)> array_filler
) {
    // using data_type = typename TypesLookup<GrpcType>::data_type;
    using vector_type = typename TypesLookup<GrpcType>::vector_type;

    auto num_vectors = num_repetitions + num_preheat;

    // Fill source vectors and send them to the server
    std::vector<vector_type> source_vectors(num_repetitions + num_preheat);
    client.DeleteArrays();
    for(auto &vec: source_vectors) {
        array_filler(vec, vec_size);
        client.PostArray(vec);
    }

    // Allocate target vectors
    std::vector<vector_type> target_vectors(num_vectors);
    for(auto &vec: target_vectors) {
        vec.reserve(vec_size);
    }

    // Preheat the connection
    for(std::size_t i = 0; i < num_preheat; ++i) {
        array_getter(target_vectors[i]);
    }

    // Run the measurement
    auto start = std::chrono::high_resolution_clock::now();
    for(std::size_t i = num_preheat; i < num_vectors; ++i) {
        array_getter(target_vectors[i]);
    }
    auto stop = std::chrono::high_resolution_clock::now();
    int64_t duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count();

    // Check correctness
    for(std::size_t i = 0; i < num_vectors; ++i) {
        for(std::size_t j = 0; j < vec_size; ++j) {
            if(source_vectors[i][j] != target_vectors[i][j]) {
                std::cout << "(i, j)=(" << i << ", " << j << ")" << std::endl;
                std::cout <<source_vectors[i][j] << "!=" << target_vectors[i][j] << std::endl;
                throw std::runtime_error("Results do not match the source vector.");
            }
        }
    }
    client.DeleteArrays();
    return duration;
}

struct Measurement {
    int64_t runtime;
    std::size_t num_repetitions;
    std::size_t vec_size;
    std::size_t chunk_size;
    std::string type_id;
    std::string method_id;

    Measurement()=default;
};

template<typename GrpcType>
std::vector<Measurement> run_all_measurements(
    ArrayServiceClient<GrpcType>& client,
    std::size_t num_measurements,
    std::size_t num_repetitions_per_measurement,
    int64_t max_time_microseconds,
    std::size_t max_vec_size
) {
    std::vector<Measurement> results;
    using vector_type = typename TypesLookup<GrpcType>::vector_type;

    std::map<std::string, std::function<void(vector_type&)>> func_without_chunking = {
        {
            "GetArray",
            [&client](auto & target_vec){client.GetArray(target_vec);}
        },
        {
            "GetArrayStreaming",
            [&client](auto & target_vec){client.GetArrayStreaming(target_vec);},
        }
    };
    std::map<std::string, std::function<void(vector_type&, std::size_t)>> func_with_chunking = {
        {
            "GetArrayChunked",
            [&client](auto & target_vec, std::size_t chunk_size){client.GetArrayChunked(target_vec, chunk_size);}
        },
        {
            "GetArrayBinaryChunked",
            [&client](auto & target_vec, std::size_t chunk_size){client.GetArrayBinaryChunked(target_vec, chunk_size);},
        }
    };

    bool cancel_measurements = false;
    for(auto pair: func_without_chunking) {
        auto method_id = pair.first;
        auto type_id = TypesLookup<GrpcType>::type_id;
        cancel_measurements = false;
        for(std::size_t vec_size = 1; vec_size <= max_vec_size; vec_size <<=1 ) {
            if(cancel_measurements) break;
            for(std::size_t count = 0; count < num_measurements; ++count) {
                if(cancel_measurements) break;
                auto runtime = measure_runtime(
                    client,
                    pair.second,
                    vec_size,
                    num_repetitions_per_measurement,
                    2,
                    [](auto & vec, std::size_t vec_size){
                        vec.resize(vec_size);
                        std::fill(vec.begin(), vec.end(), 1);
                    }
                );
                results.push_back(Measurement {
                    runtime,
                    num_repetitions_per_measurement,
                    vec_size,
                    0,
                    std::string(type_id),
                    method_id
                });
                if(runtime > max_time_microseconds) cancel_measurements = true;
            }
        }
    }
    for(auto pair: func_with_chunking) {
        auto method_id = pair.first;
        auto type_id = TypesLookup<GrpcType>::type_id;
        for(std::size_t vec_size = 1; vec_size <= max_vec_size; vec_size <<= 1) {
            cancel_measurements = false;
            for(std::size_t chunk_size = 1; chunk_size <= vec_size; chunk_size <<= 1) {
                if(cancel_measurements) break;
                auto array_getter = [pair, chunk_size](auto & vec){pair.second(vec, chunk_size);};
                for(std::size_t count = 0; count < num_measurements; ++count) {
                    if(cancel_measurements) break;
                    auto runtime = measure_runtime(
                        client,
                        array_getter,
                        vec_size,
                        num_repetitions_per_measurement,
                        2,
                        [](auto & vec, std::size_t vec_size){
                            vec.resize(vec_size);
                            std::fill(vec.begin(), vec.end(), 1);
                        }
                    );
                    results.push_back(Measurement {
                        runtime,
                        num_repetitions_per_measurement,
                        vec_size,
                        chunk_size,
                        std::string(type_id),
                        method_id
                    });
                    if(runtime > max_time_microseconds) cancel_measurements = true;
                }
            }
        }
    }

    return results;
}

void print_results(std::vector<Measurement>& res) {
    std::cout << "runtime, num_repetitions, vec_size, chunk_size, type_id, method_id" << std::endl;
    for(auto m: res) {
        std::cout <<
        m.runtime << ", " << m.vec_size << ", " << m.chunk_size <<
        m.type_id << ", " << m.method_id << ", " <<
        std::endl;
    }
}

int main() {
    grpc::ChannelArguments args;
    args.SetMaxReceiveMessageSize(-1);
    // args.SetMaxSendMessageSize(-1);
    std::string target_str = "localhost:50000";
    auto channel = grpc::CreateCustomChannel(
        target_str,
        grpc::InsecureChannelCredentials(),
        args
    );

    std::vector<Measurement> all_results;
    std::vector<Measurement> tmp_res;

    {% for dtype, _ in data_types %}
    ArrayServiceClient<ArrayService{{dtype | capitalize}}> client_{{dtype}}(channel);
    tmp_res = run_all_measurements(client_{{dtype}}, 10, 3, 100000, 10000000);
    all_results.insert(all_results.end(), tmp_res.begin(), tmp_res.end());
    {% endfor %}
    print_results(all_results);
}
